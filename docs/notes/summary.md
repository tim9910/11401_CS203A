
從多個面向考量，幫助我們在不同資料量、資料關係與操作需求下，選擇最合適、效率又穩定的資料結構。

## 1️⃣ 資料結構類型

![dstype](../images/ds.png)

## 2️⃣ 記憶體配置與結構特性

| 資料結構 | 記憶體配置與結構特性 |
|---|---|
| Array | 採用連續記憶體配置，元素採有序排列，可透過索引值index快速直接存取資料；具良好快取區域性，因此記憶體使用效率高；但陣列大小必須固定宣告，太大會浪費空間、太小又無法容納足夠資料，且執行時無法動態調整。 |
| Linked List | 節點分散存放（記憶體位址無需連續），並以指標串接，因此無法透過索引直接存取資料；需額外空間存放指標，且因記憶體非連續分布使快取區域性差，存取效能較低；另可動態新增或刪除節點，擴展彈性高。 | 
| Stack | LIFO邏輯的線性資料結構，常見的兩種操作：push放入資料及pop取出資料。僅在頂端（top）進行操作，每次取出的資料為最後放入的資料，故無需搜尋資料。 | 
| Queue | FIFO邏輯的線性資料結構，常見的兩種操作：enqueue新增從佇列尾端（rear）放入資料及dequeue從佇列前端（front）的資料刪除（取出）資料。 | 
| Hash Table | 透過 Hash Function 將Key轉換為索引，實現 Key-Value Pair 的快速存取，但需建立碰撞（Collision）處理機制，以因應不同Key指向相同索引的情況；存取資料時記憶體位置會跳躍。 |
| Tree | 採階層式（Hierarchical）架構，由節點與邊構成；資料間具父子關係，節點通常動態產生（擴展彈性高）且記憶體非連續分布，需透過指標串接。 |
| Heap | Heap 是完全二元樹，部分有序（只保證父節點與子節點間的大小關係），通常以連續陣列存放，節點可透過索引快速找到父子位置，不需額外指標，節省記憶體並提升快取效率 |
| Graph | 非線性資料結構，由頂點與邊組成，可表示多對多關係，其記憶體配置方式（如鄰接矩陣、鄰接串列）可依演算法需求彈性選擇。 |


## 3️⃣ 時間 / 空間複雜度比較

| 資料結構 | 結構特性 | 時間複雜度 | 空間複雜度 |
|---|---|---|---|
| Array | 可透過索引值index快速直接存取資料；插入刪除資料時較費時間(搬移資料) | 存取:O(1); 搜尋:O(n); 插入/刪除:O(n) | O(n) |
| Linked List | 插入刪除速度快；無法透過索引直接存取，需逐一走訪 | 搜尋:O(n); 插入/刪除:O(1) | O(n) |
| Stack | push/pop都只在頂端操作，效率穩定 | 搜尋:O(n); 插入(push)/刪除(pop):O(1) | O(n) |
| Queue | 固定從一端放入(enqueue)，另一端取出(dequeue)，操作效率穩定 | 搜尋:O(n); 插入(enqueue)/刪除(dequeue):O(1) | O(n) |
| Hash Table | 透過hash function算出一個索引值，快速找到位置 | 搜尋/插入/刪除:O(1) | O(n)，Collision可能退化 |
| Tree | 階層式結構可沿分支搜尋，無需檢查所有節點；使用高效平衡樹（如 AVL 樹、紅黑樹）搜尋效率佳 | 搜尋/插入/刪除:O(log n) | O(n) |
| Heap | 連續記憶體配置存放，可快速計算節點位置，極值操作效率高 | 極值:O(1); 插入/刪除:O(log n) | O(n) |
| Graph | 記憶體配置視演算法而定，密集圖適合鄰接矩陣，稀疏圖適合鄰接表。 | Traversal(BFS/DFS):O(V+E) | O(V+E) |


## 4️⃣ 實作難易度與維護成本

| 資料結構 | 實作難易度 | 維護成本 |
|---|---|---|
| Array | 結構最簡單，直接配置連續記憶體，實作簡單 | 維護容易、但擴充不夠彈性 |
| Linked List | 需處理指標，實作較複雜 | 需處理指標問題，維護成本較高 |
| Stack | 實作簡單，操作規則固定 | 規則清楚，維護容易 |
| Queue | 實作簡單，操作規則固定 | 規則清楚，維護容易 |
| Hash Table | 需設計hash function及Collision處理 | hash function設計不佳及Collision多，維護較麻煩 |
| Tree | 需處理節點間的關係，常用遞迴處理，實作複雜 | 插入與刪除時需維持平衡，維護成本高 |
| Heap | 需保持特定順序（最大堆積或最小堆積），實作複雜 | 插入或刪除時要重新調整，維護成本較高 |
| Graph | 需處理節點間多對多關係，依演算法需額外空間記錄走訪路徑，實作最複雜 | 需記錄走訪路徑（狀態）及處理邊的新增或刪除 |

## 5️⃣ 適用情境與限制

| 資料結構 | 適用情境 | 主要限制與缺點 |
|---|---|---|
| Array | 資料量固定，查詢多、修改少 | 插入或刪除元素需搬移資料，效率極差 |
| Linked List | 頻繁新增或刪除節點，資料量不固定 | 搜尋必須從頭開始走訪，無法直接存取 |
| Stack | 後進先出，適合遞迴呼叫、括號匹配 | 僅能存取最頂端，彈性不佳 |
| Queue | 先進先出，適合CPU排程 | 只能從兩端操作，彈性不佳 |
| Hash Table | 需快速搜尋、存取資料 | hash function設計不佳及發生嚴重碰撞時效能會大幅下降 |
| Tree | 處理具階層關係的資料 | 插入刪除需遞迴，平衡樹實作複雜 |
| Heap | 優先順序操作，如優先權佇列 | 插入刪除要調整結構，以維持順序 |
| Graph | 複雜多對多關係，如網路、路徑 | 演算法複雜，記憶體消耗大，維護成本最高 |

## 總結

選擇資料結構，其實就是在做取捨：要同時考慮資料關係、操作需求、資料量以及效能。資料量小或關係簡單時，用複雜結構反而麻煩；但當資料量大、關係複雜或需要頻繁搜尋時，樹、圖等非線性結構效率高。當然，實作與維護難易度也是考量的重點。理解每種結構的優缺點與適用情境，才能挑到最合適的方法。
